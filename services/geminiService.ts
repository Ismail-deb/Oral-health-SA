import { GoogleGenAI, Chat, GenerateContentResponse } from "@google/genai";

const API_KEY = process.env.API_KEY;

if (!API_KEY) {
  throw new Error("API_KEY environment variable not set");
}

const ai = new GoogleGenAI({ apiKey: API_KEY });

const systemInstruction = `You are a friendly and helpful AI Oral Health Assistant for South Africa.
Your goal is to provide accurate, easy-to-understand information about oral health.
You can answer questions about dental hygiene, common oral health problems, prevention tips, and general advice.
You can provide information in English, Afrikaans, Xhosa, or Zulu.
IMPORTANT: You are not a medical professional. You must not provide medical diagnoses or treatment plans.
Always include a disclaimer in your responses advising users to consult a qualified dentist or healthcare professional for any medical concerns, diagnosis, or treatment.
Keep your responses concise and helpful.`;

export function createChat(): Chat {
  return ai.chats.create({
    model: 'gemini-2.5-flash',
    config: {
      systemInstruction: systemInstruction,
    },
  });
}

export async function sendMessage(chat: Chat, message: string): Promise<GenerateContentResponse> {
  try {
    const response = await chat.sendMessage({ message });
    return response;
  } catch (error) {
    console.error("Error sending message to Gemini API:", error);
    throw new Error("Failed to get a response from the AI assistant.");
  }
}

async function retryWithBackoff<T>(
  fn: () => Promise<T>,
  retries = 3,
  delay = 1000
): Promise<T> {
  try {
    return await fn();
  } catch (error) {
    if (retries > 0) {
      console.warn(`API call failed. Retrying after ${delay}ms... (${retries} retries left)`);
      await new Promise(res => setTimeout(res, delay));
      return retryWithBackoff(fn, retries - 1, delay * 2);
    } else {
      console.error("Max retries reached. Operation failed.");
      throw error;
    }
  }
}

export async function generateImage(prompt: string): Promise<string> {
  const generate = async (): Promise<string> => {
    const response = await ai.models.generateImages({
      model: 'imagen-4.0-generate-001',
      prompt: prompt,
      config: {
        numberOfImages: 1,
        outputMimeType: 'image/png',
        aspectRatio: '1:1',
      },
    });

    if (response.generatedImages && response.generatedImages.length > 0) {
      const base64ImageBytes: string = response.generatedImages[0].image.imageBytes;
      return `data:image/png;base64,${base64ImageBytes}`;
    }
    throw new Error("No image was generated by the API.");
  };

  try {
    return await retryWithBackoff(generate);
  } catch (error) {
    console.error("Error generating image after multiple retries. Falling back to a placeholder SVG.", error);
    
    // Fallback for AI assistant avatar
    const placeholderSvg = `
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 100 100">
          <defs>
             <linearGradient id="aiGrad" x1="0%" y1="0%" x2="100%" y2="100%">
              <stop offset="0%" style="stop-color:#38bdf8;stop-opacity:1" />
              <stop offset="100%" style="stop-color:#14b8a6;stop-opacity:1" />
            </linearGradient>
          </defs>
          <circle cx="50" cy="50" r="50" fill="url(#aiGrad)"/>
          <path d="M35 55 Q 50 70 65 55" stroke="white" stroke-width="5" fill="none" stroke-linecap="round"/>
        </svg>
      `;
    
    // Minify and encode the SVG to create a data URL
    const minifiedSvg = placeholderSvg.replace(/(\r\n|\n|\r)/gm, "").replace(/\s+/g, ' ').replace(/> </g, '><').trim();
    const base64Svg = btoa(minifiedSvg);
    return `data:image/svg+xml;base64,${base64Svg}`;
  }
}